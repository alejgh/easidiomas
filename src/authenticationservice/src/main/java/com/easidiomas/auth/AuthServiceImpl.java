package com.easidiomas.auth;

import com.easidiomas.auth.clients.usersservice.User;
import com.easidiomas.auth.clients.usersservice.UsersServiceClient;
import com.easidiomas.auth.encryption.AESDecryptor;
import com.easidiomas.auth.encryption.AESEncryptor;
import com.google.gson.Gson;
import io.grpc.stub.StreamObserver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URISyntaxException;
import java.util.Optional;

/**
 * This implementation extends the one generated by gRPC. It overrides the two
 * declared proto service methods and implementes de desired functionality.
 */
public class AuthServiceImpl extends AuthenticationServiceGrpc.AuthenticationServiceImplBase {

    private static final Logger LOGGER = LoggerFactory.getLogger(AuthServiceImpl.class);
    private static final long TOKEN_LIVE_TIME_MS = Long.parseLong(System.getProperty("TOKEN_LIVE_TIME_MS", "600000"));
    private static final String USERS_SERVICE_ADDR = System.getProperty("USERS_SERVICE_ADDR", "localhost:5002");

    private final UsersServiceClient usersServiceClient = new UsersServiceClient();

    @Override
    public void requestToken(Authservice.TokenRequest request, StreamObserver<Authservice.TokenResponse> responseObserver) {
        final String username = request.getUsername();
        final String password = request.getPassword();
        LOGGER.info(String.format("User [%s] requested a new token.", username));

        // 1. Look for the combination of user and password in the users service.
        LOGGER.info(String.format("Looking for user [%s] in the users service", username));
        Optional<User> userData = Optional.empty();
        try {
            userData = usersServiceClient.authenticate(username, password);
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }
        if(userData.isPresent()) {
            // 2. If the user exists, generate a passport for it with its data.
            final User user = userData.get();
            LOGGER.info(String.format("User [%s] found in users service", username));
            LOGGER.info(String.format("Generating passport for user [%s].", username));
            String expirationDate = Long.toString(System.currentTimeMillis() + TOKEN_LIVE_TIME_MS);
            Authservice.Passport passport = Authservice.Passport.newBuilder()
                    .setUserId(Long.toString(user.getId()))
                    .setRole(user.getRole())
                    .setName(user.getName())
                    .setSurname(user.getSurname())
                    //.setAvatarUrl(user.getAvatarUrl())
                    .setExpirationDate(expirationDate)
                    .build();

            LOGGER.info(String.format("Generated passport for user [%s]: %s", username, passport));

            // 3. Convert the passport to JSON object.
            String jsonPassport = "";

            try {
                Gson gson = new Gson();
                jsonPassport = gson.toJson(passport);
            } catch (Exception e) {
                LOGGER.error("Error while serializing passport as a JSON object: " + e.toString());
                responseObserver.onError(e);
                return;
            }

            // 4. Cypher the passport with AES.
            LOGGER.info(String.format("Generating token for user passport: %s", passport));
            String tokenString = AESEncryptor.encrypt(jsonPassport);
            LOGGER.info(String.format("Generated token [%s] for user passport: %s",tokenString, passport));

            // 5. Create a token object from the cyphered json.
            Authservice.TokenResponse response = Authservice.TokenResponse.newBuilder()
                    .setResponseStatus(Authservice.TokenResponse.ResponseStatus.OK)
                    .setMessage("Token created successfully")
                    .setTokenExpirationDate(expirationDate)
                    .setTokenPermissions(Integer.toString(user.getRole()))
                    .setTokenGenerated(tokenString)
                    .build();

            responseObserver.onNext(response);
            responseObserver.onCompleted();
            return;

        } else {
            // If the user does not exists...
            LOGGER.info(String.format("User [%s] not found in users service", username));
            Authservice.TokenResponse response = Authservice.TokenResponse.newBuilder()
                    .setResponseStatus(Authservice.TokenResponse.ResponseStatus.USER_NOT_FOUND)
                    .setMessage("The provided credentials do not match any registered user.")
                    .setTokenPermissions("-1")
                    .setTokenGenerated("")
                    .build();

            responseObserver.onNext(response);
            responseObserver.onCompleted();
            return;
        }
    }

    @Override
    public void requestPassport(Authservice.PassportRequest request, StreamObserver<Authservice.PassportResponse> responseObserver) {
        String tokenString = request.getToken();

        LOGGER.info(String.format("Passport generation request received for token: %s", tokenString));

        // 1. Decrypt the token.
        LOGGER.info(String.format("Decrypting token: %s", tokenString));
        String jsonToken = AESDecryptor.decrypt(tokenString);
        LOGGER.info(String.format("Decrypted token: [%s] on to: %s", tokenString, jsonToken));

        // 2. Convert to passport.
        LOGGER.info(String.format("Deserializing token [%s] as a Passport", tokenString));
        Authservice.Passport passport = null;
        try {
            Gson gson = new Gson();
            passport = gson.fromJson(jsonToken, Authservice.Passport.class);
        } catch (Exception e) {
            LOGGER.error("Error while deserializing the jsonToken: " + e.toString());
            Authservice.PassportResponse response = Authservice.PassportResponse.newBuilder()
                    .setResponseStatus(Authservice.PassportResponse.ResponseStatus.TOKEN_NOT_VALID)
                    .setMessage("Token not valid.")
                    .setTokenAuthenticated(tokenString)
                    .build();

            responseObserver.onNext(response);
            responseObserver.onCompleted();
            return;
        }
        LOGGER.info(String.format("Deserialized token [%s] as a Passport: %s", tokenString, passport));

        // 3. Check the expirationDate.
        LOGGER.info(String.format("Checking expiration date of the passport"));
        Long expirationDate = null;
        try {
            expirationDate = Long.parseLong(passport.getExpirationDate());
        } catch (Exception e) {
            LOGGER.error("Error while deserializing the passport date: " + e.getStackTrace());

            Authservice.PassportResponse response = Authservice.PassportResponse.newBuilder()
                    .setResponseStatus(Authservice.PassportResponse.ResponseStatus.TOKEN_NOT_VALID)
                    .setMessage("Token not valid.")
                    .setTokenAuthenticated(tokenString)
                    .build();

            responseObserver.onNext(response);
            responseObserver.onCompleted();
            return;
        }

        if (expirationDate < System.currentTimeMillis()) {
            // The passport is no longer valid.
            LOGGER.info(String.format("Passport %s has expired", passport));
            Authservice.PassportResponse response = Authservice.PassportResponse.newBuilder()
                    .setResponseStatus(Authservice.PassportResponse.ResponseStatus.TOKEN_EXPIRED)
                    .setMessage("Token has expired.")
                    .setTokenAuthenticated(tokenString)
                    .setTokenExpirationDate(Long.toString(expirationDate))
                    .build();
            responseObserver.onNext(response);
            responseObserver.onCompleted();
            return;
        }

        // 4. Return passport.
        LOGGER.info(String.format("Passport generated and valid for token [%s]", tokenString));
        Authservice.PassportResponse response = Authservice.PassportResponse.newBuilder()
                .setResponseStatus(Authservice.PassportResponse.ResponseStatus.OK)
                .setMessage("Passport created successfully")
                .setTokenAuthenticated(tokenString)
                .setPassport(passport)
                .setTokenExpirationDate(Long.toString(expirationDate))
                .build();
        responseObserver.onNext(response);
        responseObserver.onCompleted();
        return;
    }
}
